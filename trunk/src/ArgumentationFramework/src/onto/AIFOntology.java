// file: AIFOntology.java generated by ontology bean generator.  DO NOT EDIT, UNLESS YOU ARE REALLY SURE WHAT YOU ARE DOING!
package onto;

import jade.content.onto.*;
import jade.content.schema.*;

/** file: AIFOntology.java
 * @author OntologyBeanGenerator v4.1
 * @version 2011/02/8, 19:01:12
 */
public class AIFOntology extends jade.content.onto.Ontology  {

  private static final long serialVersionUID = -3637768939741971919L;

  //NAME
  public static final String ONTOLOGY_NAME = "AIF";
  // The singleton instance of this ontology
  private static Ontology theInstance = new AIFOntology();
  public static Ontology getInstance() {
     return theInstance;
  }


   // VOCABULARY
    public static final String SCHEME_HASSCHEMENAME="hasSchemeName";
    public static final String SCHEME_HASPREMISEDESCRIPTION="hasPremiseDescription";
    public static final String SCHEME_HASCONCLUSIONDESCRIPTION="hasConclusionDescription";
    public static final String SCHEME="Scheme";
    public static final String PREMISEDESC_ENTAILS="entails";
    public static final String PREMISEDESC="PremiseDesc";
    public static final String PREFERENCESCHEME="PreferenceScheme";
    public static final String S_NODE_FULFILSSCHEME="fulfilsScheme";
    public static final String S_NODE_EDGEFROMSNODE="edgeFromSNode";
    public static final String S_NODE="S_Node";
    public static final String PREMISE_SUPPORTS="supports";
    public static final String PREMISE_UNDERMINESPRESUMPTION="underminesPresumption";
    public static final String PREMISE_FULFILSPREMISEDESC="fulfilsPremiseDesc";
    public static final String PREMISE="Premise";
    public static final String CONFLICTSCHEME="ConflictScheme";
    public static final String CA_NODE_ISATTACKED="isAttacked";
    public static final String CA_NODE_CANODE_ATTACKS="caNode_Attacks";
    public static final String CA_NODE="CA_Node";
    public static final String FORM_HASDESCRIPTION="hasDescription";
    public static final String FORM="Form";
    public static final String PA_NODE="PA_Node";
    public static final String LOGICALPREFERENCESCHEME="LogicalPreferenceScheme";
    public static final String CONCLUSIONDESC="ConclusionDesc";
    public static final String CONCLUSION_FULFILSCONCLUSIONDESC="fulfilsConclusionDesc";
    public static final String CONCLUSION="Conclusion";
    public static final String INDUCTIVEINFERENCE="InductiveInference";
    public static final String DEDUCTIVEINFERENCE="DeductiveInference";
    public static final String I_NODE_CANODE_ISATTACKED="caNode_isAttacked";
    public static final String I_NODE_ATTACKS="attacks";
    public static final String I_NODE_EDGEFROMINODE="edgeFromINode";
    public static final String I_NODE_TEXT="text";
    public static final String I_NODE="I_Node";
    public static final String PRESUMPTIVEPREFERENCESCHEME="PresumptivePreferenceScheme";
    public static final String RULESCHEME="RuleScheme";
    public static final String PRESUMPTIVEINFERENCESCHEME_HASPRESUMPTION="hasPresumption";
    public static final String PRESUMPTIVEINFERENCESCHEME_HASEXCEPTION="hasException";
    public static final String PRESUMPTIVEINFERENCESCHEME="PresumptiveInferenceScheme";
    public static final String NODE="Node";
    public static final String RA_NODE_HASPREMISE="hasPremise";
    public static final String RA_NODE_HASCONCLUSION="hasConclusion";
    public static final String RA_NODE="RA_Node";
    public static final String PRESUMPTION="Presumption";

  /**
   * Constructor
  */
  private AIFOntology(){ 
    super(ONTOLOGY_NAME, BasicOntology.getInstance());
    try { 

    // adding Concept(s)
    ConceptSchema presumptionSchema = new ConceptSchema(PRESUMPTION);
    add(presumptionSchema, onto.Presumption.class);
    ConceptSchema rA_NodeSchema = new ConceptSchema(RA_NODE);
    add(rA_NodeSchema, onto.RA_Node.class);
    ConceptSchema nodeSchema = new ConceptSchema(NODE);
    add(nodeSchema, onto.Node.class);
    ConceptSchema presumptiveInferenceSchemeSchema = new ConceptSchema(PRESUMPTIVEINFERENCESCHEME);
    add(presumptiveInferenceSchemeSchema, onto.PresumptiveInferenceScheme.class);
    ConceptSchema ruleSchemeSchema = new ConceptSchema(RULESCHEME);
    add(ruleSchemeSchema, onto.RuleScheme.class);
    ConceptSchema presumptivePreferenceSchemeSchema = new ConceptSchema(PRESUMPTIVEPREFERENCESCHEME);
    add(presumptivePreferenceSchemeSchema, onto.PresumptivePreferenceScheme.class);
    ConceptSchema i_NodeSchema = new ConceptSchema(I_NODE);
    add(i_NodeSchema, onto.I_Node.class);
    ConceptSchema deductiveInferenceSchema = new ConceptSchema(DEDUCTIVEINFERENCE);
    add(deductiveInferenceSchema, onto.DeductiveInference.class);
    ConceptSchema inductiveInferenceSchema = new ConceptSchema(INDUCTIVEINFERENCE);
    add(inductiveInferenceSchema, onto.InductiveInference.class);
    ConceptSchema conclusionSchema = new ConceptSchema(CONCLUSION);
    add(conclusionSchema, onto.Conclusion.class);
    ConceptSchema conclusionDescSchema = new ConceptSchema(CONCLUSIONDESC);
    add(conclusionDescSchema, onto.ConclusionDesc.class);
    ConceptSchema logicalPreferenceSchemeSchema = new ConceptSchema(LOGICALPREFERENCESCHEME);
    add(logicalPreferenceSchemeSchema, onto.LogicalPreferenceScheme.class);
    ConceptSchema pA_NodeSchema = new ConceptSchema(PA_NODE);
    add(pA_NodeSchema, onto.PA_Node.class);
    ConceptSchema formSchema = new ConceptSchema(FORM);
    add(formSchema, onto.Form.class);
    ConceptSchema cA_NodeSchema = new ConceptSchema(CA_NODE);
    add(cA_NodeSchema, onto.CA_Node.class);
    ConceptSchema conflictSchemeSchema = new ConceptSchema(CONFLICTSCHEME);
    add(conflictSchemeSchema, onto.ConflictScheme.class);
    ConceptSchema premiseSchema = new ConceptSchema(PREMISE);
    add(premiseSchema, onto.Premise.class);
    ConceptSchema s_NodeSchema = new ConceptSchema(S_NODE);
    add(s_NodeSchema, onto.S_Node.class);
    ConceptSchema preferenceSchemeSchema = new ConceptSchema(PREFERENCESCHEME);
    add(preferenceSchemeSchema, onto.PreferenceScheme.class);
    ConceptSchema premiseDescSchema = new ConceptSchema(PREMISEDESC);
    add(premiseDescSchema, onto.PremiseDesc.class);
    ConceptSchema schemeSchema = new ConceptSchema(SCHEME);
    add(schemeSchema, onto.Scheme.class);

    // adding AgentAction(s)

    // adding AID(s)

    // adding Predicate(s)


    // adding fields
    rA_NodeSchema.add(RA_NODE_HASCONCLUSION, conclusionSchema, 0, ObjectSchema.UNLIMITED);
    rA_NodeSchema.add(RA_NODE_HASPREMISE, premiseSchema, 0, ObjectSchema.UNLIMITED);
    presumptiveInferenceSchemeSchema.add(PRESUMPTIVEINFERENCESCHEME_HASEXCEPTION, conflictSchemeSchema, 0, ObjectSchema.UNLIMITED);
    presumptiveInferenceSchemeSchema.add(PRESUMPTIVEINFERENCESCHEME_HASPRESUMPTION, presumptionSchema, 0, ObjectSchema.UNLIMITED);
    i_NodeSchema.add(I_NODE_TEXT, (TermSchema)getSchema(BasicOntology.STRING), 0, ObjectSchema.UNLIMITED);
    i_NodeSchema.add(I_NODE_EDGEFROMINODE, s_NodeSchema, 0, ObjectSchema.UNLIMITED);
    i_NodeSchema.add(I_NODE_ATTACKS, cA_NodeSchema, 0, ObjectSchema.UNLIMITED);
    i_NodeSchema.add(I_NODE_CANODE_ISATTACKED, cA_NodeSchema, 0, ObjectSchema.UNLIMITED);
    conclusionSchema.add(CONCLUSION_FULFILSCONCLUSIONDESC, conclusionDescSchema, 0, ObjectSchema.UNLIMITED);
    formSchema.add(FORM_HASDESCRIPTION, (TermSchema)getSchema(BasicOntology.STRING), 0, ObjectSchema.UNLIMITED);
    cA_NodeSchema.add(CA_NODE_CANODE_ATTACKS, i_NodeSchema, 0, ObjectSchema.UNLIMITED);
    cA_NodeSchema.add(CA_NODE_ISATTACKED, conclusionSchema, 0, ObjectSchema.UNLIMITED);
    premiseSchema.add(PREMISE_FULFILSPREMISEDESC, premiseDescSchema, 0, ObjectSchema.UNLIMITED);
    premiseSchema.add(PREMISE_UNDERMINESPRESUMPTION, presumptionSchema, 0, ObjectSchema.UNLIMITED);
    premiseSchema.add(PREMISE_SUPPORTS, rA_NodeSchema, 0, ObjectSchema.UNLIMITED);
    s_NodeSchema.add(S_NODE_EDGEFROMSNODE, nodeSchema, 0, ObjectSchema.UNLIMITED);
    s_NodeSchema.add(S_NODE_FULFILSSCHEME, schemeSchema, 0, ObjectSchema.UNLIMITED);
    premiseDescSchema.add(PREMISEDESC_ENTAILS, presumptionSchema, 0, ObjectSchema.UNLIMITED);
    schemeSchema.add(SCHEME_HASCONCLUSIONDESCRIPTION, conclusionDescSchema, 0, ObjectSchema.UNLIMITED);
    schemeSchema.add(SCHEME_HASPREMISEDESCRIPTION, premiseDescSchema, 0, ObjectSchema.UNLIMITED);
    schemeSchema.add(SCHEME_HASSCHEMENAME, (TermSchema)getSchema(BasicOntology.STRING), 0, ObjectSchema.UNLIMITED);

    // adding name mappings

    // adding inheritance
    presumptionSchema.addSuperSchema(formSchema);
    rA_NodeSchema.addSuperSchema(s_NodeSchema);
    presumptiveInferenceSchemeSchema.addSuperSchema(ruleSchemeSchema);
    ruleSchemeSchema.addSuperSchema(schemeSchema);
    presumptivePreferenceSchemeSchema.addSuperSchema(preferenceSchemeSchema);
    i_NodeSchema.addSuperSchema(nodeSchema);
    deductiveInferenceSchema.addSuperSchema(ruleSchemeSchema);
    inductiveInferenceSchema.addSuperSchema(ruleSchemeSchema);
    conclusionSchema.addSuperSchema(i_NodeSchema);
    conclusionDescSchema.addSuperSchema(formSchema);
    logicalPreferenceSchemeSchema.addSuperSchema(preferenceSchemeSchema);
    pA_NodeSchema.addSuperSchema(s_NodeSchema);
    formSchema.addSuperSchema(nodeSchema);
    cA_NodeSchema.addSuperSchema(s_NodeSchema);
    conflictSchemeSchema.addSuperSchema(schemeSchema);
    premiseSchema.addSuperSchema(i_NodeSchema);
    s_NodeSchema.addSuperSchema(nodeSchema);
    preferenceSchemeSchema.addSuperSchema(schemeSchema);
    premiseDescSchema.addSuperSchema(formSchema);

   }catch (java.lang.Exception e) {e.printStackTrace();}
  }
}
